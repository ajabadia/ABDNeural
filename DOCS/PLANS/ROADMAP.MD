# NEXUS: Master Development Roadmap & Specification

Este documento sirve como la gu√≠a t√©cnica y filos√≥fica para el desarrollo de NEXUS, un instrumento de res√≠ntesis inspirado en la tecnolog√≠a de modelos neurales (Hartmann Neuron), dise√±ado para alta eficiencia en m√∫ltiples plataformas (PC, Mac, Linux, RPi).

---

## üü¢ FASE 0-8: FUNDAMENTOS Y S√çNTESIS [COMPLETADO]
*Objetivo: Establecer una base de c√≥digo robusta y un motor de s√≠ntesis expresivo.*

- [x] **Arquitectura y UI**: Sistema de pesta√±as, abstracci√≥n de par√°metros y optimizaci√≥n del hilo de audio.
- [x] **Motor de Modelos Espectrales**: Migraci√≥n a un sistema de s√≠ntesis basado en modelos de 64 parciales, con capacidad de morphing lineal (A/B).
- [x] **Escultura de Materia Sonora**: Implementaci√≥n de los par√°metros `Inharmonicity` y `Roughness` para la transformaci√≥n del timbre.

---

## üü¢ FASE 10: NAVEGACI√ìN AVANZADA [COMPLETADO]
*Objetivo: Implementar un sistema de morphing 2D para un control t√≠mbrico superior.*

- [x] **Tarea 10.1: Neural Pad (Componente X/Y)**: Se ha reemplazado el morphing lineal por un pad X/Y que permite la mezcla entre cuatro modelos espectrales (A, B, C, D).
- [x] **Tarea 10.2 (Parcial): Bugs Cr√≠ticos Solucionados**: Se ha corregido el bug de la nota MIDI fija y se ha eliminado el visualizador duplicado de la UI.

---

## üü£ FASE 9: OPTIMIZACI√ìN Y DESPLIEGUE (APLAZADO)
*Objetivo: Rendimiento garantizado en Raspberry Pi y estabilidad en DAWs comerciales.*

- [ ] **Tarea 9.1: SIMD Optimization (Neon/SSE)**: Refactorizar `Resonator::processSample` para usar instrucciones vectoriales.
- [ ] **Tarea 9.2: Escalabilidad Din√°mica**: Implementar modos de calidad (Ultra/Eco) para adaptarse a diferentes hardwares.

---

## üîµ FASE 11: NEXUS MODEL MAKER (Herramienta de Creaci√≥n de Sonidos)
*Objetivo: Crear una aplicaci√≥n de escritorio para analizar archivos de audio y generar los archivos `.nexusmodel`.*

- [ ] **Tareas 11.1 a 11.7**: Desarrollo de una aplicaci√≥n JUCE independiente con UI, motor de an√°lisis FFT, y capacidad de exportar modelos. Incluye un plan de evoluci√≥n con algoritmos avanzados (LPC, CQT) y la capacidad de importar modelos del Hartmann Neuron.

---

## üü° FASE 12: GESTI√ìN Y CONTROL TOTAL
*Objetivo: Dotar a NEXUS de un sistema de gesti√≥n de sonidos profesional y control MIDI completo.*

### Tarea 12.1: Sistema de Presets (.nexuspreset)
-   **Especificaci√≥n**: Implementar la capacidad de guardar y cargar el estado completo del sintetizador.
-   **Tecnolog√≠a**: Aprovechar `juce::AudioProcessorValueTreeState` para serializar el estado a XML y guardarlo en un archivo.
-   **UI**: A√±adir botones de "Save" y "Load" en la interfaz, junto con un display para el nombre del preset actual.

### Tarea 12.2: Carga de Modelos Espectrales (.nexusmodel)
-   **Especificaci√≥n**: Permitir al usuario cargar los archivos `.nexusmodel` en cada uno de los cuatro slots (A, B, C, D) del `Resonator`.
-   **UI**: A√±adir cuatro botones ("Load A", "Load B", etc.) en el `OscillatorPanel`, cerca del `XYPad`.
-   **L√≥gica**: Implementar el parseo del archivo JSON `.nexusmodel` y cargar los datos en el `Resonator`.

### Tarea 12.3: Mapeo de MIDI CC y Controles Est√°ndar
-   **Especificaci√≥n**: Dotar a NEXUS de un control MIDI completo, combinando un sistema de mapeo din√°mico ("MIDI Learn") con soporte para los controles est√°ndar m√°s importantes.
-   **Nota General**: Toda la funcionalidad MIDI deber√° ser documentada en el `README.md`.

#### Sub-tarea 12.3.1: Soporte para Controles MIDI Est√°ndar (Hard-coded)
-   **Objetivo**: Implementar el manejo de los mensajes MIDI m√°s comunes para una experiencia "plug-and-play".
-   **Controles a Implementar**:
    -   **Pitch Bend**: Conectar el mensaje de Pitch Wheel para modular la frecuencia base de las voces activas.
    -   **Sustain Pedal (CC #64)**: Implementar la l√≥gica de "hold" para las notas, manteniendo las voces activas incluso despu√©s de soltar las teclas.
    -   **Modulation Wheel (CC #1)**: Mapear por defecto a un par√°metro expresivo, como `morphY` o la intensidad de un futuro LFO.
    -   **Main Volume (CC #7)**: Conectar directamente al par√°metro `masterLevel`.
    -   **Program Change**: Implementar la l√≥gica para cambiar entre presets del sintetizador.

#### Sub-tarea 12.3.2: Sistema de Mapeo Din√°mico ("MIDI Learn")
-   **Objetivo**: Permitir al usuario asignar cualquier control MIDI CC a cualquier par√°metro del sintetizador.
-   **UI**: Implementar un men√∫ contextual (clic derecho) en cada control (sliders, knobs, XYPad) con la opci√≥n "MIDI Learn".
-   **L√≥gica**:
    1.  Al activar "MIDI Learn", el sistema esperar√° el siguiente mensaje MIDI CC.
    2.  Al recibirlo, crear√° una asociaci√≥n entre ese n√∫mero de CC y el ID del par√°metro.
    3.  Este mapa de asociaciones se guardar√° como parte del preset (`.nexuspreset`).
    4.  El `processBlock` procesar√° los mensajes MIDI CC entrantes y actualizar√° los par√°metros correspondientes seg√∫n el mapa activo.

---

## üü§ FASE 13: INTERFAZ DE HARDWARE VIRTUAL (Pantalla LCD)
*Objetivo: Reemplazar el t√≠tulo est√°tico por una pantalla LCD informativa como puente para una futura integraci√≥n con hardware f√≠sico.*

### Tarea 13.1: Dise√±o del Componente LCD (`LcdDisplay`)
-   **Especificaci√≥n**: Crear un componente JUCE que simule una pantalla LCD de caracteres, con texto pixelado y efecto de "glow".
-   **Funcionalidad**: Deber√° ser capaz de mostrar varias l√≠neas de texto con diferentes alineaciones.

### Tarea 13.2: L√≥gica de Informaci√≥n Contextual
-   **Especificaci√≥n**: La pantalla mostrar√° informaci√≥n relevante basada en la interacci√≥n del usuario.
-   **L√≥gica**: Mostrar el nombre y el valor del √∫ltimo par√°metro modificado. Cuando no se interact√∫a, mostrar√° el nombre del preset actual.

### Tarea 13.3: Integraci√≥n en la Interfaz Principal
-   **Especificaci√≥n**: Reemplazar la `juce::Label` del t√≠tulo en `NEXUSEditor` por el nuevo componente `LcdDisplay`.

### Tarea 13.4: Abstracci√≥n para Hardware F√≠sico
-   **Especificaci√≥n**: Dise√±ar la comunicaci√≥n con el `LcdDisplay` de forma modular.
-   **Sugerencia**: Crear una clase `DisplayController` que gestione qu√© informaci√≥n mostrar. El `LcdDisplay` (y en el futuro, un `SerialLcdController` para RPi) se suscribir√°n a los cambios de este controlador.

---

## ‚ö™ TAREAS PENDIENTES DE AUDITOR√çA Y CALIDAD
- [x] **(BUG)** El teclado MIDI siempre reproduce la misma nota, ignorando el pitch. - **SOLUCIONADO**
- [x] **(UI)** Eliminar el visualizador duplicado o no funcional. - **SOLUCIONADO**
- [ ] Implementar Unit Tests para los algoritmos de interpolaci√≥n.
- [x] Documentar cada m√≥dulo siguiendo el formato de `reglas.md`.
- [ ] Validar consumo de CPU en RPi 4/5.
