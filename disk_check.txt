/*
  ==============================================================================

    NeurotikEngine.cpp
    Created: 30 Jan 2026
    Description: Implementation of the Neurotik engine.

  ==============================================================================
*/

#include "NeurotikEngine.h"
#include "../Synthesis/NeurotikVoice.h"
#include "../DSPUtils.h"

namespace NEURONiK::DSP {

NeurotikEngine::NeurotikEngine()
{
    activeVoiceLimit.store(8);
    for (int i = 0; i < 32; ++i)
        voices.push_back(std::make_unique<Synthesis::NeurotikVoice>());
}

void NeurotikEngine::prepare(double sampleRate, int samplesPerBlock)
{
    BaseEngine::prepare(sampleRate, samplesPerBlock);
}

void NeurotikEngine::renderNextBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)
{
    const int numSamples = buffer.getNumSamples();
    
    // 1. Update LFOs and Global Parameters
    updateParameters();

    // 2. Process MIDI events
    processMidiBuffer(midiMessages);

    buffer.clear();

    // 3. Render Voices
    for (auto& v : voices)
    {
        if (v->isActive())
            v->renderNextBlock(buffer, 0, numSamples);
    }

    // 4. Global FX & LFO Sampling
    applyGlobalFX(buffer);
}

void NeurotikEngine::updateParameters()
{
    BaseEngine::updateParameters();
    applyModulation();

    for (auto& v : voices)
    {
        if (auto* nv = dynamic_cast<::NEURONiK::DSP::Synthesis::NeurotikVoice*>(v.get()))
            nv->setParams(pendingVoiceParams);
    }
}

void NeurotikEngine::applyModulation()
{
    float sources[6] = { 
        0.0f,                   // Off
        lfo1Value.load(),       // LFO 1
        lfo2Value.load(),       // LFO 2
        0.0f,                   // PB
        0.0f,                   // MW
        0.0f                    // AT
    };

    for (auto& v : voices) v->resetModulations();

    for (int i = 0; i < 4; ++i)
    {
        const auto& route = currentGlobalParams.modMatrix[i];
        if (route.source == 0 || route.destination == 0) continue;
        
        float rawMod = sources[juce::jlimit(0, 5, route.source)] * route.amount;
        
        switch (route.destination)
        {
            case 1: for (auto& v : voices) v->modLevel += rawMod; break;
            case 4: for (auto& v : voices) v->modMorphX += rawMod; break;
            case 5: for (auto& v : voices) v->modMorphY += rawMod; break;
            case 17: currentGlobalParams.saturationAmt += rawMod; break;
            case 23: for (auto& v : voices) v->modInharmonicity += rawMod; break;
            case 26: for (auto& v : voices) v->modResonance += rawMod; break;
            case 27: for (auto& v : voices) v->modUnison += rawMod; break;
            default: break;
        }
    }
}

void NeurotikEngine::getEnvelopeLevels(float& amp, float& filter) const
{
    for (const auto& v : voices)
    {
        if (v->isActive())
        {
            if (auto* nv = dynamic_cast<Synthesis::NeurotikVoice*>(v.get()))
            {
                amp = nv->getAmpEnvelopeLevel();
                filter = 0.0f;
                return;
            }
        }
    }
    amp = 0.0f;
    filter = 0.0f;
}

void NeurotikEngine::getSpectralData(float* destination64) const
{
    bool found = false;
    for (const auto& v : voices)
    {
        if (v->isActive())
        {
            if (auto* nv = dynamic_cast<Synthesis::NeurotikVoice*>(v.get()))
            {
                const auto& partials = nv->getPartialAmplitudes();
                for (int i = 0; i < 64; ++i) destination64[i] = partials[i];
                found = true;
                break;
            }
        }
    }
    
    if (!found)
    {
        std::fill(destination64, destination64 + 64, 0.0f);
    }
}

void NeurotikEngine::loadModel(const NEURONiK::Common::SpectralModel& model, int slot)
{
    for (auto& v : voices)
    {
        if (auto* nv = dynamic_cast<::NEURONiK::DSP::Synthesis::NeurotikVoice*>(v.get()))
            nv->loadModel(model, slot);
    }
}

void NeurotikEngine::setVoiceParams(const NEURONiK::DSP::Synthesis::NeurotikVoice::Params& p)
{
    pendingVoiceParams = p;
}

void NeurotikEngine::handleMidiEvent(const juce::MidiMessage& m)
{
    int channel = m.getChannel();

    if (m.isNoteOn())
    {
        int limit = activeVoiceLimit.load();
        for (int i = 0; i < limit; ++i)
        {
            if (!voices[i]->isActive())
            {
                voices[i]->setChannel(channel);
                voices[i]->noteOn(m.getNoteNumber(), m.getFloatVelocity());
                return;
            }
        }
        voices[0]->setChannel(channel);
        voices[0]->noteOn(m.getNoteNumber(), m.getFloatVelocity());
    }
    else if (m.isNoteOff())
    {
        for (auto& v : voices)
        {
            if (v->isActive() && v->getCurrentlyPlayingNote() == m.getNoteNumber() && v->getChannel() == channel)
            {
                v->noteOff(m.getFloatVelocity(), true);
            }
        }
    }
    else if (m.isPitchWheel())
    {
        float bendSemitones = ((float)m.getPitchWheelValue() - 8192.0f) / 8192.0f * 48.0f;
        for (auto& v : voices)
        {
            if (v->isActive() && (v->getChannel() == channel || channel == 1))
                v->notePitchBend(bendSemitones);
        }
    }
    else if (m.isAftertouch() || m.isChannelPressure())
    {
        float pressureVal = m.isAftertouch() ? (float)m.getAfterTouchValue() : (float)m.getChannelPressureValue();
        float pressure = pressureVal / 127.0f;
        
        for (auto& v : voices)
        {
            if (v->isActive() && (v->getChannel() == channel || channel == 1))
                v->notePressure(pressure);
        }
    }
    else if (m.isController() && m.getControllerNumber() == 74)
    {
        float timbre = (float)m.getControllerValue() / 127.0f;
        for (auto& v : voices)
        {
            if (v->isActive() && (v->getChannel() == channel || channel == 1))
                v->noteTimbre(timbre);
        }
    }
}


} // namespace NEURONiK::DSP
/*
  ==============================================================================

    CustomUIComponents.h
    Created: 26 Jan 2026
    Description: Shared UI components and LookAndFeel for NEURONiK.
                 Follows DRY principle for knobs and modulation visualization.

  ==============================================================================
*/

#pragma once

#include <juce_gui_basics/juce_gui_basics.h>
#include <juce_audio_processors/juce_audio_processors.h>
#include <cstdint>
#include "../Main/ModulationTargets.h"
#include "ThemeManager.h"
#include "MidiLearner.h"

// Forward declaration to break circular dependency
class NEURONiKProcessor;

namespace NEURONiK::UI {

/**
 * A specialized slider that holds a reference to a modulation target index.
 */
class ModulatedSlider : public juce::Slider
{
public:
    ModulatedSlider() = default;
    
    void setModulationTarget(::NEURONiK::ModulationTarget target, ::NEURONiKProcessor* proc);
    std::atomic<float>* getModulationAtomic() const;

private:
    ::NEURONiK::ModulationTarget modTarget = ::NEURONiK::ModulationTarget::Count;
    ::NEURONiKProcessor* processor = nullptr;
};

/**
 * A shared LookAndFeel for all knobs that supports real-time modulation display.
 */
class SharedKnobLookAndFeel : public juce::LookAndFeel_V4
{
public:
    SharedKnobLookAndFeel()
    {
        const auto& theme = ThemeManager::getCurrentTheme();
        setColour(juce::Slider::thumbColourId, theme.knobPointer);
        setColour(juce::Slider::rotarySliderFillColourId, theme.accent.withAlpha(0.3f));
    }

    void drawRotarySlider(juce::Graphics& g, int x, int y, int width, int height, float sliderPos,
                          const float rotaryStartAngle, const float rotaryEndAngle, juce::Slider& slider) override
    {
        auto area = juce::Rectangle<int>(x, y, width, height).toFloat().reduced(6.0f);
        auto diam = juce::jmin(area.getWidth(), area.getHeight());
        auto bounds = juce::Rectangle<float>(diam, diam).withCentre(area.getCentre());
        
        auto centreX = bounds.getCentreX();
        auto centreY = bounds.getCentreY();
        auto rotaryRange = rotaryEndAngle - rotaryStartAngle;
        auto angle = rotaryStartAngle + sliderPos * rotaryRange;

        // 1. Background Track
        g.setColour(ThemeManager::getCurrentTheme().background.withAlpha(0.3f));
        g.drawEllipse(bounds, 3.0f);

        // 2. Knob Body
        auto knobArea = bounds.reduced(4.0f);
        const auto& theme = ThemeManager::getCurrentTheme();
        juce::ColourGradient knobGrad(theme.text.withAlpha(0.15f), centreX, knobArea.getY(),
                                     theme.background.withAlpha(0.4f), centreX, knobArea.getBottom(), false);
        g.setGradientFill(knobGrad);
        g.fillEllipse(knobArea);
        
        g.setColour(theme.text.withAlpha(0.1f));
        g.drawEllipse(knobArea, 1.0f);

        // 3. Modulation Arc (Read from specialized slider)
        std::atomic<float>* modAtom = nullptr;
        if (auto* modSlider = dynamic_cast<ModulatedSlider*>(&slider))
            modAtom = modSlider->getModulationAtomic();

        if (modAtom != nullptr)
        {
            auto range = slider.getRange();
            float currentMod = modAtom->load(std::memory_order_relaxed);
            float normMod = (float)((currentMod - range.getStart()) / range.getLength());
            auto modAngle = rotaryStartAngle + normMod * rotaryRange;

            juce::Path modPath;
            modPath.addArc(bounds.getX(), bounds.getY(), bounds.getWidth(), bounds.getHeight(), rotaryStartAngle, modAngle, true);
            
            const auto& currentTheme = ThemeManager::getCurrentTheme();
            g.setColour(currentTheme.modulationRing.withAlpha(0.4f));
            g.strokePath(modPath, juce::PathStrokeType(4.0f, juce::PathStrokeType::curved, juce::PathStrokeType::rounded));
            
            g.setColour(currentTheme.modulationRing);
            g.strokePath(modPath, juce::PathStrokeType(2.0f, juce::PathStrokeType::curved, juce::PathStrokeType::rounded));
        }

        // 4. Pointer
        float pointerAlpha = slider.isEnabled() ? 0.8f : 0.2f;
        juce::Path p;
        p.addRectangle(-1.0f, -knobArea.getWidth() * 0.5f, 2.0f, knobArea.getWidth() * 0.3f);
        p.applyTransform(juce::AffineTransform::rotation(angle).translated(centreX, centreY));
        g.setColour(ThemeManager::getCurrentTheme().knobPointer.withAlpha(pointerAlpha));
        g.fillPath(p);

        // 5. Disabled Overlay
        if (!slider.isEnabled())
        {
            g.setColour(ThemeManager::getCurrentTheme().background.withAlpha(0.6f));
            g.fillEllipse(bounds);
        }
    }
};

/**
 * Common structure for a UI control, keeping all pieces together.
 */
struct RotaryControl {
    ModulatedSlider slider;
    juce::Label label;
    std::unique_ptr<juce::AudioProcessorValueTreeState::SliderAttachment> attachment;
    std::unique_ptr<MidiLearner> midiLearner;
};

/**
 * Utility class for configuring controls without repeating boilerplate code.
 */
class UIUtils {
public:
    static void setupRotaryControl(juce::Component& parent,
                                  RotaryControl& ctrl, 
                                  const juce::String& paramID, 
                                  const juce::String& labelText,
                                  juce::AudioProcessorValueTreeState& vts,
                                  class ::NEURONiKProcessor& processor,
                                  juce::LookAndFeel& lnf,
                                  ::NEURONiK::ModulationTarget modTarget = ::NEURONiK::ModulationTarget::Count)
    {
        ctrl.slider.setSliderStyle(juce::Slider::RotaryHorizontalVerticalDrag);
        ctrl.slider.setTextBoxStyle(juce::Slider::TextBoxBelow, true, 60, 20);
        ctrl.slider.setColour(juce::Slider::textBoxOutlineColourId, juce::Colours::transparentBlack);
        ctrl.slider.setLookAndFeel(&lnf);
        
        // Pass modulation target to specialized slider
        if (modTarget != ::NEURONiK::ModulationTarget::Count)
            ctrl.slider.setModulationTarget(modTarget, &processor);
            
        parent.addAndMakeVisible(ctrl.slider);

        ctrl.label.setText(labelText, juce::dontSendNotification);
        ctrl.label.setJustificationType(juce::Justification::centred);
        ctrl.label.setFont(juce::Font(juce::FontOptions(12.0f).withStyle("Bold")));
        parent.addAndMakeVisible(ctrl.label);

        ctrl.attachment = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment>(vts, paramID, ctrl.slider);
        
        // 2-decimal precision (Override attachment/parameter text)
        ctrl.slider.textFromValueFunction = [](double v) { 
            return juce::String(v, 2); 
        };

        ctrl.midiLearner = std::make_unique<MidiLearner>(processor, ctrl.slider, paramID);
    }
};

/**
 * A reusable "Glass" container for grouping components.
 */
class GlassBox : public juce::Component
{
public:
    GlassBox(const juce::String& name = "") : title(name) 
    {
        titleLabel.setText(title, juce::dontSendNotification);
        titleLabel.setJustificationType(juce::Justification::centredLeft);
        titleLabel.setFont(juce::Font(juce::FontOptions(13.0f).withStyle("Bold")));
        titleLabel.setColour(juce::Label::textColourId, ThemeManager::getCurrentTheme().accent.withAlpha(0.7f));
        addAndMakeVisible(titleLabel);
    }

    void paint(juce::Graphics& g) override
    {
        auto area = getLocalBounds().toFloat();
        
        // Background Glass effect
        const auto& theme = ThemeManager::getCurrentTheme();
        juce::ColourGradient glassGrad(theme.text.withAlpha(0.06f), 0, 0,
                                      theme.text.withAlpha(0.01f), 0, area.getHeight(), false);
        g.setGradientFill(glassGrad);
        g.fillRoundedRectangle(area, 8.0f);
        
        // Border
        g.setColour(theme.text.withAlpha(0.1f));
        g.drawRoundedRectangle(area, 8.0f, 1.0f);

        // Header line if title exists
        if (title.isNotEmpty())
        {
            auto lineY = 22.0f;
            g.setColour(ThemeManager::getCurrentTheme().accent.withAlpha(0.2f));
            g.drawLine(8.0f, lineY, area.getWidth() - 8.0f, lineY, 1.0f);
        }
    }

    void resized() override
    {
        if (title.isNotEmpty())
            titleLabel.setBounds(10, 2, getWidth() - 20, 18);
    }

    juce::Rectangle<int> getContentArea() 
    { 
        return getLocalBounds().reduced(8).withTrimmedTop(title.isNotEmpty() ? 20 : 0); 
    }

private:
    juce::String title;
    juce::Label titleLabel;
};

/**
 * A standardized "Neural Glass" button for NEURONiK.
 */
class CustomButton : public juce::TextButton
{
public:
    CustomButton(const juce::String& name = "") : juce::TextButton(name) 
    {
        setMouseCursor(juce::MouseCursor::PointingHandCursor);
    }

    void paintButton(juce::Graphics& g, bool shouldDrawButtonAsHighlighted, bool shouldDrawButtonAsDown) override
    {
        auto area = getLocalBounds().toFloat();
        auto cornerSize = 4.0f;

        // 1. Background (Matte Dark Glass)
        const auto& theme = ThemeManager::getCurrentTheme();
        g.setColour(theme.surface.withAlpha(0.8f));
        g.fillRoundedRectangle(area, cornerSize);

        // 2. Dynamic Border
        float borderAlpha = shouldDrawButtonAsDown ? 0.9f : (shouldDrawButtonAsHighlighted ? 0.6f : 0.3f);
        g.setColour(theme.accent.withAlpha(borderAlpha));
        g.drawRoundedRectangle(area.reduced(0.5f), cornerSize, 1.0f);

        // 3. Inner Glow on press
        if (shouldDrawButtonAsDown)
        {
            g.setColour(theme.accent.withAlpha(0.1f));
            g.fillRoundedRectangle(area.reduced(1.0f), cornerSize);
        }

        // 4. Text / Label
        g.setColour(shouldDrawButtonAsDown ? theme.text : theme.accent.withAlpha(0.8f));
        g.setFont(juce::Font(juce::FontOptions(area.getHeight() * 0.5f).withStyle("Bold")));
        g.drawText(getButtonText(), area, juce::Justification::centred, false);
    }
};

/**
 * A modular LED indicator component with a glow effect.
 */
class LedIndicator : public juce::Component
{
public:
    LedIndicator(juce::Colour color = juce::Colour()) : ledColor(color) 
    {
        if (ledColor == juce::Colour())
            ledColor = ThemeManager::getCurrentTheme().accent;
    }

    void setValue(float newValue) 
    { 
        if (value != newValue)
        {
            value = newValue; 
            repaint(); 
        }
    }

    void paint(juce::Graphics& g) override
    {
        auto area = getLocalBounds().toFloat().reduced(1.0f);
        auto centre = area.getCentre();
        auto radius = juce::jmin(area.getWidth(), area.getHeight()) * 0.5f;

        // 1. Off/Dim background
        g.setColour(ledColor.withAlpha(0.1f));
        g.fillEllipse(area);

        if (value > 0.001f)
        {
            float alpha = juce::jlimit(0.0f, 1.0f, value);
            
            // 2. Glow
            juce::ColourGradient glow(ledColor.withAlpha(0.4f * alpha), centre.x, centre.y,
                                     ledColor.withAlpha(0.0f), centre.x + radius * 2.0f, centre.y, true);
            g.setGradientFill(glow);
            g.fillEllipse(area.expanded(2.5f));

            // 3. Core
            g.setColour(ledColor.withAlpha(0.8f * alpha));
            g.fillEllipse(area.reduced(1.5f));
            
            // 4. Center Shine
            g.setColour(ThemeManager::getCurrentTheme().text.withAlpha(0.4f * alpha));
            g.fillEllipse(juce::Rectangle<float>(radius * 0.4f, radius * 0.4f).withCentre(centre.translated(-radius*0.25f, -radius*0.25f)));
        }

        // Border
        g.setColour(ThemeManager::getCurrentTheme().text.withAlpha(0.15f));
        g.drawEllipse(area, 0.8f);
    }

private:
    juce::Colour ledColor;
    float value = 0.0f;
};

} // namespace NEURONiK::UI
#pragma once
#include <juce_audio_processors/juce_audio_processors.h>
#include <juce_audio_basics/juce_audio_basics.h>
#include <juce_audio_utils/juce_audio_utils.h>
#include <array>
#include <atomic>
#include <map>
#include "../Serialization/PresetManager.h"
#include "MidiMappingManager.h"
#include "../DSP/ISynthesisEngine.h"
#include "../Common/SpectralModel.h"
#include "ModulationTargets.h"

namespace NEURONiK::DSP { class NeuronikEngine; }

class NEURONiKProcessor : public juce::AudioProcessor,
                     public juce::AudioProcessorValueTreeState::Listener,
                     public juce::MidiKeyboardState::Listener,
                     public juce::ValueTree::Listener
{
public:
    NEURONiKProcessor();
    ~NEURONiKProcessor() override;

    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;
    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;
    void processBlock(juce::AudioBuffer<double>&, juce::MidiBuffer&) override;

    void parameterChanged(const juce::String& parameterID, float newValue) override;

    // --- MIDI Learn ---
    void enterMidiLearnMode(const juce::String& paramID);
    void clearMidiLearnForParameter(const juce::String& paramID);

    // --- Model Loading ---
    void loadModel(const juce::File& file, int slot);
    void reloadModels();

    // --- Patch Copy/Paste ---
    void copyPatchToClipboard();
    void pastePatchFromClipboard();

    // --- Editor Creation ---
    juce::AudioProcessorEditor* createEditor() override;
    bool hasEditor() const override;

    // --- JUCE Boilerplate ---
    const juce::String getName() const override;
    bool acceptsMidi() const override { return true; }
    bool producesMidi() const override { return false; }
    bool isMidiEffect() const override { return false; }
    double getTailLengthSeconds() const override { return 0.0; }
    int getNumPrograms() override { return 1; }
    int getCurrentProgram() override { return 0; }
    void setCurrentProgram(int) override {}
    const juce::String getProgramName(int) override { return "Default"; }
    void changeProgramName(int, const juce::String&) override {}

    // --- State Management ---
    void getStateInformation(juce::MemoryBlock&) override;
    void setStateInformation(const void*, int) override;

    // --- Getters ---
    juce::AudioProcessorValueTreeState& getAPVTS() { return apvts; }
    juce::MidiKeyboardState& getKeyboardState() { return keyboardState; }
    const std::array<juce::String, 4>& getModelNames() const { return modelNames; }
    NEURONiK::Serialization::PresetManager& getPresetManager() { return *presetManager; }
    NEURONiK::Serialization::PresetManager& getPresetManager() const { return *presetManager; }
    NEURONiK::Main::MidiMappingManager& getMidiMappingManager() { return *midiMappingManager; }

    // --- Real-time Visualization Data ---
    std::array<std::atomic<float>, 64> spectralDataForUI;
    
    // Envelope Visualization Atomics
    std::atomic<float> uiEnvelope { 0.0f };     // Amp Env Level
    std::atomic<float> uiFEnvelope { 0.0f };    // Filter Env Level
    
    // Parameters for ADSR Visualizers (snapshot from APVTS)
    std::atomic<float> uiAttack { 0.0f }, uiDecay { 0.0f }, uiSustain { 0.0f }, uiRelease { 0.0f };
    std::atomic<float> uiFAttack { 0.0f }, uiFDecay { 0.0f }, uiFSustain { 0.0f }, uiFRelease { 0.0f };
    
    // Macro visualization
    std::atomic<float> uiMorphX { 0.0f };
    std::atomic<float> uiMorphY { 0.0f };

    std::atomic<float> lfo1ValueForUI { 0.0f };
    std::atomic<float> lfo2ValueForUI { 0.0f };

    // --- Polyphony Management ---
    struct EditorSettings {
        std::unique_ptr<juce::FileChooser> chooser;
    };

    void setPolyphony(int numVoices);
    int getPolyphony() const;
    EditorSettings& getEditorSettings();

public:
    // --- Modulation Access (Safe Atomic Indexing) ---
    std::atomic<float>& getModulationValue(::NEURONiK::ModulationTarget target) noexcept
    {
        return modulationValues[static_cast<size_t>(target)];
    }

    const std::atomic<float>& getModulationValue(::NEURONiK::ModulationTarget target) const noexcept
    {
        return modulationValues[static_cast<size_t>(target)];
    }

protected:
    // --- MidiKeyboardState::Listener overrides ---
    void handleNoteOn(juce::MidiKeyboardState*, int midiChannel, int midiNoteNumber, float velocity) override;
    void handleNoteOff(juce::MidiKeyboardState*, int midiChannel, int midiNoteNumber, float velocity) override;

    // ValueTree::Listener
    void valueTreePropertyChanged(juce::ValueTree& tree, const juce::Identifier& property) override;
    void valueTreeRedirected(juce::ValueTree& tree) override;


private:
    std::array<std::atomic<float>, ::NEURONiK::ModulationTargetCount> modulationValues;

    juce::AudioProcessorValueTreeState apvts;
    std::unique_ptr<NEURONiK::Serialization::PresetManager> presetManager;
    juce::MidiKeyboardState keyboardState;
    std::unique_ptr<NEURONiK::DSP::ISynthesisEngine> engine;

    // --- UI MIDI Message Injection (Safe FIFO) ---
    juce::AbstractFifo midiFifo;
    struct QueuedMidiMessage {
        juce::MidiMessage message;
        int sampleOffset;
    };
    std::array<QueuedMidiMessage, 1024> midiQueue;

    void synchronizeEngineParameters();

    // --- Lock-Free Command Queue (Model Loading) ---
    struct EngineCommand {
        enum Type { LoadModel, Reset, Unknown };
        Type type = Unknown;
        int slot = 0;
        NEURONiK::Common::SpectralModel modelData;
    };
    
    juce::AbstractFifo commandFifo;
    std::array<EngineCommand, 32> commandQueue;
    
    void processCommands();

    std::array<juce::String, 4> modelNames;

    // --- MIDI Real-time values for Modulation ---
    std::atomic<float> pitchBendValue { 0.5f };
    std::atomic<float> modWheelValue { 0.0f };
    std::atomic<float> aftertouchValue { 0.0f };

    // --- MIDI Learn ---
    std::atomic<bool> midiLearnActive { false };
    juce::String parameterToLearn;
    std::unique_ptr<NEURONiK::Main::MidiMappingManager> midiMappingManager;

    std::atomic<int> currentPolyphony { 8 };
    EditorSettings editorSettings;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(NEURONiKProcessor)
};
