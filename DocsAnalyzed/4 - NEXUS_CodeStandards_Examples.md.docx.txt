
NEXUS Code Standards & Examples
Este documento muestra el estilo de código ESPERADO en NEXUS.

I. SEPARACIÓN DE RESPONSABILIDADES
❌ BAD: Todo mezclado
cpp
// Source/Main/PluginProcessor.cpp - WRONG
class PluginProcessor : public juce::AudioProcessor {
    // UI stuff aquí (WRONG)
    juce::Slider pitch_slider;
    juce::Label pitch_label;
    
    // DSP stuff aquí (WRONG)
    float oscillator_phase = 0.0f;
    std::vector<float> harmonics;
    
    // Lógica MIDI mezclada (WRONG)
    void processMIDI() {
        // cientos de líneas
    }
    
    void processBlock(AudioBuffer<float>& buffer, MidiBuffer& midi) override {
        // EVERYTHING aquí
        // Dibujar UI
        // Procesar MIDI
        // Síntesis
        // Efectos
        // 2000+ líneas (PESADILLA)
    }
};
✅ GOOD: Separación clara
cpp
// Source/Main/PluginProcessor.h
class PluginProcessor : public juce::AudioProcessor {
    // Solo audio processing orchestration
    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void processBlock(AudioBuffer<float>& buffer, MidiBuffer& midiMessages) override;
    
    // State management (read-only, thread-safe)
    juce::AudioProcessorValueTreeState apvts;
    
private:
    // Coordinadores, no implementadores
    std::unique_ptr<VoiceAllocator> voice_allocator_;
    std::unique_ptr<EffectsChain> effects_;
    std::unique_ptr<MIDIProcessor> midi_processor_;
    std::unique_ptr<FeatureExtractor> feature_extractor_;
    std::unique_ptr<NeuralControlNetwork> neural_net_;
};
// Source/Main/PluginProcessor.cpp
void PluginProcessor::processBlock(AudioBuffer<float>& buffer, 
                                    MidiBuffer& midiMessages) {
    // 1. Process MIDI (delegado)
    midi_processor_->process(midiMessages, *voice_allocator_);
    
    // 2. Extract features (delegado)
    auto features = feature_extractor_->extract(buffer);
    
    // 3. Get neural controls (delegado)
    auto controls = neural_net_->predict(features);
    
    // 4. Synthesize voices (delegado)
    voice_allocator_->processBlock(controls, buffer);
    
    // 5. Apply effects (delegado)
    effects_->processBlock(buffer);
}
Ventaja: Cada línea es clara, fácil testear, fácil debugear.

II. THREAD-SAFETY: El Hilo de Audio
❌ BAD: Violaciones comunes
cpp
// processBlock - WRONG
void Voice::process(AudioBuffer<float>& buffer) {
    // ❌ Allocation (puede reasignar)
    std::vector<float> temp = generate_harmonics();
    
    // ❌ Lock (puede bloquear)
    std::lock_guard<std::mutex> lock(param_mutex);
    float cutoff = param_cutoff;
    
    // ❌ I/O (imprevisible latencia)
    std::cout << "Processing"; // Prohibido
    
    // ❌ Virtual call sin protección
    synth_->complexMethod();
    
    // ❌ Dynamic memory
    float* data = new float[1024];
    // (memory leak si hay excepción)
}
✅ GOOD: Audio thread seguro
cpp
// Source/DSP/Synthesis/ResonatorVoice.h
class ResonatorVoice {
public:
    // Setter seguro desde UI thread
    void setFilterCutoff(float hz) noexcept {
        filter_cutoff_hz_.store(hz, std::memory_order_release);
    }
    
    // Process seguro en audio thread
    float processSample() noexcept {  // noexcept = promesa de no lanzar
        // ✅ Load parámetro de forma atomic
        float cutoff = filter_cutoff_hz_.load(std::memory_order_acquire);
        
        // ✅ Pre-allocated (no new/delete)
        float harmonic_sum = 0.0f;
        for (int i = 0; i < 64; ++i) {
            harmonic_sum += oscillators_[i].process();  // Pre-constructed
        }
        
        // ✅ Cálculos puros
        float filtered = filter_.process(harmonic_sum, cutoff);
        
        // ✅ No I/O, no allocations, no locks
        return filtered;
    }
private:
    // Atomic para comunicación segura
    std::atomic<float> filter_cutoff_hz_{5000.0f};
    
    // Pre-allocated (nunca se redimensiona)
    std::array<Oscillator, 64> oscillators_;
    Filter filter_;
};
Comunicación UI → Audio: std::atomic
cpp
// UI thread (Main thread)
void SynthesizerTab::sliderValueChanged(Slider* slider) {
    if (slider == cutoff_slider) {
        float value = slider->getValue();
        processor_.setFilterCutoff(value);  // Seguro
    }
}
// Audio thread
void PluginProcessor::processBlock(...) {
    // Lee parámetro de forma segura (no bloquea)
    voice_allocator_->setFilterCutoff(
        *apvts.getRawParameterValue(PARAM_FILTER_CUTOFF)
    );
}
Comunicación Audio → UI: FIFO lock-free
cpp
// Source/DSP/Analysis/SpectrumAnalyzer.h
class SpectrumAnalyzer {
private:
    juce::AbstractFifo spectrum_fifo_{4096};
    std::array<float, 256> spectrum_buffer_;
    
public:
    // Audio thread: Push spectrum
    void pushSpectrum(const std::array<float, 256>& spec) noexcept {
        int num_to_write = 256;
        int write_space = spectrum_fifo_.getFreeSpace();
        
        if (write_space >= num_to_write) {
            auto write_ptr = spectrum_fifo_.write(num_to_write);
            if (write_ptr > 0) {
                std::copy(spec.begin(), spec.end(), 
                         spectrum_buffer_.begin());
                spectrum_fifo_.finishWrite(num_to_write);
            }
        }
        // Si queue llena, descarta (es visualización, ok perder frame)
    }
    
    // UI thread: Pull spectrum
    void pullAndDisplay(juce::Graphics& g) {
        int num_ready = spectrum_fifo_.getNumReady();
        if (num_ready > 0) {
            spectrum_fifo_.read(num_ready);
            // Dibujar spectrum_buffer_
        }
    }
};

III. GESTIÓN DE MEMORIA: Smart Pointers
❌ BAD: Raw pointers
cpp
class Processor {
private:
    // Raw pointers = responsabilidad de delete
    Voice* voice_1;  // ¿Quién lo deleta?
    Voice* voice_2;  // ¿Orden de deletion?
    std::vector<Voice*> voices;  // ¿Si resize() falla?
    
public:
    Processor() {
        voice_1 = new Voice();  // Si new throws?
        voice_2 = new Voice();  // Si esto falla, voice_1 leaks
    }
    
    ~Processor() {
        delete voice_1;  // ¿Si otro thread accede?
        delete voice_2;
    }
};
✅ GOOD: Smart pointers
cpp
class Processor {
private:
    // std::unique_ptr = automatic lifetime
    std::unique_ptr<Voice> voice_1;
    std::unique_ptr<Voice> voice_2;
    std::vector<std::unique_ptr<Voice>> voices;
    
public:
    Processor() 
        : voice_1(std::make_unique<Voice>()),
          voice_2(std::make_unique<Voice>()) {
        // Si make_unique falla, no hay leak
        // Destructores se llaman automáticamente
    }
    
    // No necesita destructor (RAII)
    // ~Processor() {} // Automatic!
};
// Uso:
std::unique_ptr<Processor> processor = std::make_unique<Processor>();
// Destruido automáticamente cuando sale de scope
Raw pointers SOLO como observadores (non-owning)
cpp
class EffectsChain {
public:
    void addFilter(Filter* filter) {  // Non-owning observer
        filters_.push_back(filter);    // NO toma posesión
    }
    
private:
    std::vector<Filter*> filters_;  // Observadores, no propietarios
};
// Uso:
auto owned_filter = std::make_unique<Filter>();
effects_chain.addFilter(owned_filter.get());  // Pasar observer
// owned_filter se destruye cuando sale de scope

IV. PARÁMETROS: APVTS Es Única Fuente de Verdad
❌ BAD: Variables sueltas
cpp
class Voice {
private:
    // Variables independientes = desincronización con DAW
    float pitch_coarse_ = 0.0f;
    float pitch_fine_ = 0.0f;
    float harmonic_count_ = 32.0f;
    
public:
    void setPitchCoarse(float val) { pitch_coarse_ = val; }
    float getPitchCoarse() { return pitch_coarse_; }
    // Manual sync con APVTS = error-prone
    
    void saveState(MemoryBlock& data) {
        // Manual serialización = fácil olvidar parámetro
        data.write(&pitch_coarse_, sizeof(float));
        // ¿pitch_fine_? ¿harmonic_count_?
    }
};
✅ GOOD: APVTS centralizado
cpp
// Source/State/ParameterDefinitions.h
namespace NexusParams {
    const juce::Identifier PITCH_COARSE = "pitchCoarse";
    const juce::Identifier PITCH_FINE = "pitchFine";
    const juce::Identifier HARMONIC_COUNT = "harmonicCount";
}
// Source/Main/PluginProcessor.h
class PluginProcessor : public juce::AudioProcessor {
    juce::AudioProcessorValueTreeState apvts{
        createAudioProcessorValueTreeState(*this)
    };
    
    void processBlock(AudioBuffer<float>& buffer, 
                      MidiBuffer& midiMessages) override {
        // Leer parámetros desde APVTS (thread-safe)
        float pitch_coarse = 
            *apvts.getRawParameterValue(NexusParams::PITCH_COARSE);
        float pitch_fine = 
            *apvts.getRawParameterValue(NexusParams::PITCH_FINE);
        float harmonic_count = 
            *apvts.getRawParameterValue(NexusParams::HARMONIC_COUNT);
        
        voice_allocator_->setPitch(pitch_coarse + pitch_fine);
        voice_allocator_->setHarmonicCount((int)harmonic_count);
    }
};
// APVTS automáticamente:
// ✅ Sincronización DAW
// ✅ Serialización (save/load)
// ✅ Undo/Redo
// ✅ Automation

V. ENUMS Y CONSTANTES: Evitar Magic Numbers
❌ BAD: Magic numbers
cpp
void Voice::process() {
    if (mode == 0) {  // ¿Qué es 0?
        // Monophonic
    } else if (mode == 1) {  // ¿Y 1?
        // Polyphonic
    } else if (mode == 2) {  // ¿Unison?
        // ???
    }
    
    // 64 = ??? (harmonic count??)
    for (int i = 0; i < 64; ++i) {
        oscillators_[i].process();
    }
}
✅ GOOD: Named enums & constants
cpp
// Source/State/ParameterDefinitions.h
namespace NexusParams {
    enum class VoiceMode { Monophonic = 0, Polyphonic = 1, Unison = 2 };
    
    static constexpr int HARMONIC_COUNT = 64;
    static constexpr int HARMONIC_COUNT_RPI = 32;
}
// Source/DSP/Voice.h
class Voice {
private:
    static constexpr int NUM_OSCILLATORS = NexusParams::HARMONIC_COUNT;
    std::array<Oscillator, NUM_OSCILLATORS> oscillators_;
    
public:
    void setVoiceMode(NexusParams::VoiceMode mode) {
        switch (mode) {
            case NexusParams::VoiceMode::Monophonic:
                // Clear intent
                break;
            case NexusParams::VoiceMode::Polyphonic:
                // Clear intent
                break;
            case NexusParams::VoiceMode::Unison:
                // Clear intent
                break;
        }
    }
};

VI. CONST CORRECTNESS
❌ BAD: Sin const
cpp
class Filter {
public:
    float process(float input) {  // ¿Modifica state interno?
        // No se sabe sin leer implementación
        return input * 0.5f;
    }
    
    void getCoefficients(float* a0, float* a1) {  // ¿Seguro acceso paralelo?
        *a0 = coeff_a0_;
        *a1 = coeff_a1_;
    }
    
private:
    float coeff_a0_ = 1.0f;  // ¿Se modifica?
};
✅ GOOD: Const correctness
cpp
class Filter {
public:
    // Promete no modificar state (compilador verifica)
    float process(float input) const noexcept {
        return input * coeff_a0_;  // ¿Acceso a coeff_a0_? ✓ permitido
        // coeff_a0_ = 2.0f;  // ✗ Compilador error
    }
    
    // Promesa explícita: seguro para acceso concurrente read-only
    float getCoeffA0() const noexcept { return coeff_a0_; }
    float getCoeffA1() const noexcept { return coeff_a1_; }
    
    // Setter explícito para cambios
    void setCoefficients(float a0, float a1) noexcept {
        coeff_a0_ = a0;
        coeff_a1_ = a1;
    }
    
private:
    float coeff_a0_ = 1.0f;
    float coeff_a1_ = 0.0f;
};

VII. NOEXCEPT: Promesas al Compilador
❌ BAD: Sin noexcept
cpp
class Oscillator {
public:
    // ¿Puede lanzar excepción?
    float process(float freq) {
        return std::sin(2.0f * M_PI * phase_);  // No throws
    }
    
    void reset() {
        phase_ = 0.0f;  // No throws
    }
};
// Compilador no sabe si es seguro en audio thread
✅ GOOD: noexcept donde sea
cpp
class Oscillator {
public:
    // Promesa: nunca lanza excepción
    float process(float freq) const noexcept {
        return std::sin(2.0f * M_PI * phase_);
    }
    
    void reset() noexcept {
        phase_ = 0.0f;
    }
    
    // Setter puede fallar (allocation)
    bool setWavetable(const float* table, int size) {
        try {
            wavetable_.assign(table, table + size);  // Puede throw
            return true;
        } catch (...) {
            return false;
        }
    }
    
private:
    float phase_ = 0.0f;
    std::vector<float> wavetable_;  // Pre-allocated o falla en setter
};

VIII. NOMENCLATURA CONSISTENTE
❌ BAD: Inconsistente
cpp
class SynthVoice {
public:
    // PascalCase método
    void ProcessAudio(float* output) { }
    
    // camelCase método
    void setSynthGain(float val) { }
    
    // MixedCase miembro privado
    float _PhaseAccumulator;  // Leading underscore (no estándar JUCE)
    float gain;  // Sin trailing underscore (inconsistente)
};
✅ GOOD: Consistente (JUCE style)
cpp
class SynthVoice {
public:
    // camelCase métodos public
    void processAudio(const AudioBuffer<float>& input,
                      AudioBuffer<float>& output) noexcept;
    
    void setSynthGain(float gainLinear) noexcept;
    float getSynthGain() const noexcept { return gain_; }
    
    // Enums: PascalCase
    enum class OscillatorType { Sine, Triangle, Sawtooth };
    
private:
    // lowercase + trailing underscore para miembros privados
    float phase_accumulator_ = 0.0f;
    float gain_ = 1.0f;
    OscillatorType oscillator_type_ = OscillatorType::Sine;
    
    // Static constants: UPPER_CASE
    static constexpr int HARMONIC_COUNT = 64;
    static constexpr float NYQUIST_FREQ = 24000.0f;
};

IX. COMENTARIOS ÚTILES
❌ BAD: Comentarios obvios
cpp
// Increment phase
phase_ += frequency_;
// Check if voice is active
if (is_active_) {
    // Process audio
    output = process();
}
// Return gain value
return gain_;
✅ GOOD: Comentarios que explican POR QUÉ
cpp
// Phase accumulation: we use a separate oscillator phase
// rather than relying on sample count to allow independent
// pitch modulation (vibrato, pitch bend) without artifacts
phase_ += frequency_;
// Only process active voices to reduce CPU load on
// systems with many voices (especially important on RPi)
if (is_active_) {
    output = process();
}
// Gain is stored in linear scale (not dB) for faster
// multiplication in audio loops (dB conversion done in UI)
return gain_;

X. CLASE EJEMPLO COMPLETA
cpp
// Source/DSP/CoreModules/Oscillator.h
#pragma once
#include <juce_core/juce_core.h>
#include <array>
#include <cmath>
/**
 * Simple sine wave oscillator with phase accumulation.
 * 
 * Design decisions:
 * - Single oscillator, not wavetable (wavetable is separate class)
 * - Phase in [0, 1) range for numerical stability vs. radians
 * - No allocation post-construction (real-time safe)
 */
class Oscillator {
public:
    /**
     * Set the frequency in Hz.
     * Safe to call from any thread (uses atomic).
     */
    void setFrequency(float frequencyHz) noexcept {
        frequency_hz_.store(frequencyHz, std::memory_order_release);
    }
    
    /**
     * Process one sample.
     * Returns sine wave value in [-1, 1].
     * MUST be called from audio thread only.
     */
    float processSample(float phaseModulation = 0.0f) noexcept {
        // Load frequency atomically (set from UI thread)
        float freq = frequency_hz_.load(std::memory_order_acquire);
        
        // Apply phase modulation (e.g., from LFO)
        float modulated_phase = phase_ + phaseModulation;
        if (modulated_phase >= 1.0f) modulated_phase -= 1.0f;
        if (modulated_phase < 0.0f) modulated_phase += 1.0f;
        
        // Generate sine
        float output = std::sin(2.0f * M_PI * modulated_phase);
        
        // Advance phase for next sample
        // At 48kHz: 440Hz oscillator → phase increment = 440 / 48000 = ~0.00917
        phase_ += freq / sample_rate_;
        if (phase_ >= 1.0f) phase_ -= 1.0f;
        
        return output;
    }
    
    /**
     * Reset phase to zero.
     * Called on note-on to ensure deterministic start.
     */
    void reset() noexcept {
        phase_ = 0.0f;
    }
    
    /**
     * Initialize sample rate (called in prepareToPlay).
     * Non-real-time safe (may allocate, take lock, etc).
     */
    void setSampleRate(double sampleRateHz) noexcept {
        sample_rate_ = sampleRateHz;
    }
    
private:
    // Frequency stored as atomic for UI → Audio thread communication
    // (UI can call setFrequency without blocking audio thread)
    std::atomic<float> frequency_hz_{440.0f};
    
    // Phase in [0, 1) range (modulo operation faster than radians)
    float phase_ = 0.0f;
    
    // Sample rate set during prepareToPlay
    double sample_rate_ = 48000.0;
};

CONCLUSIÓN
El código de NEXUS debe ser:
✅ Modular: Cada clase responsable de una cosa
✅ Thread-safe: Audio thread inviolable
✅ Memory-safe: Smart pointers, no leaks
✅ Clear: Nombres de variable descriptivos, const-correct
✅ Documented: Comentarios explican POR QUÉ, no QUÉ
✅ Testeable: Bajo acoplamiento, fácil de unit-test
Si violas estos principios, el código se vuelve mantenible→ pesadilla en semanas.

Usa estos ejemplos como referencia al code review.

FIN DEL ARCHIVO 3 (NEXUS_CodeStandards_Examples.md)

