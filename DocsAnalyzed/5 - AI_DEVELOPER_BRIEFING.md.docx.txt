
AI DEVELOPER BRIEFING: C√≥mo Usar Esta Especificaci√≥n
Este documento explica c√≥mo trabajar con la especificaci√≥n de NEXUS.

I. ARCHIVOS QUE RECIBIR√ÅS
Recibir√°s¬†5 documentos maestros:
NEXUS_Architecture_Specification.md¬†(1,145 l√≠neas)
Visi√≥n completa del proyecto
Estructura de directorios
Principios arquitect√≥nicos
Roadmap de 16 semanas
NEXUS_ParameterDefinitions_Template.h¬†(232 l√≠neas)
Todos los par√°metros centralizados
Enums, constantes, rangos
Factory APVTS
NEXUS_CodeStandards_Examples.md¬†(692 l√≠neas)
Patrones GOOD vs BAD
Ejemplos de c√≥digo real
Clase completa ejemplo (Oscillator)
AI_DEVELOPER_BRIEFING.md¬†(este archivo)
C√≥mo trabajar con especificaci√≥n
Conversaciones tipo
Timeline realista
DELIVERY_CHECKLIST.md¬†(444 l√≠neas)
Validaci√≥n por fase
Archivos entregables esperados
Tests de calidad

II. FLUJO DE TRABAJO RECOMENDADO
Paso 1: Lectura Inicial (1-2 horas)
text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1. Lee ARCHITECTURE (secciones I-V) ‚îÇ
‚îÇ    ‚Üí Entiende estructura de dirs     ‚îÇ
‚îÇ    ‚Üí Principios SoC, thread-safety   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 2. Lee CODE STANDARDS               ‚îÇ
‚îÇ    ‚Üí Aprende estilo esperado         ‚îÇ
‚îÇ    ‚Üí Mira ejemplos GOOD/BAD          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 3. Lee PARAMETER DEFINITIONS        ‚îÇ
‚îÇ    ‚Üí Ve todos los par√°metros        ‚îÇ
‚îÇ    ‚Üí Entiende enums y rangos         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 4. Consulta BRIEFING y CHECKLIST   ‚îÇ
‚îÇ    ‚Üí Sabe c√≥mo proceder              ‚îÇ
‚îÇ    ‚Üí Qu√© validar en cada fase        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Paso 2: Planificaci√≥n (30 minutos)
text
PHASE 1 (Semana 1): Project Setup
‚îú‚îÄ Create directory structure
‚îú‚îÄ Configure CMakeLists.txt
‚îú‚îÄ Create ParameterDefinitions.h
‚îî‚îÄ Create PluginProcessor skeleton
PHASE 2 (Semanas 2-4): DSP Core
‚îú‚îÄ Implement Oscillator
‚îú‚îÄ Implement Envelope
‚îú‚îÄ Implement ResonatorVoice
‚îî‚îÄ Implement VoiceAllocator
PHASE 3 (Semanas 5-6): Neural Control
‚îú‚îÄ Implement FeatureExtractor
‚îú‚îÄ Implement NeuralControlNetwork
‚îî‚îÄ Load .pt model
PHASE 4 (Semanas 7-8): UI
‚îú‚îÄ Create tabbed interface
‚îú‚îÄ Implement SynthesizerTab
‚îú‚îÄ Implement ModulationTab
‚îî‚îÄ Connect to APVTS
PHASE 5 (Semanas 9-10): MIDI + Polish
‚îú‚îÄ MIDI note processing
‚îú‚îÄ CC mapping
‚îú‚îÄ Preset save/load
‚îî‚îÄ CPU optimization pass 1
PHASE 6 (Semanas 11+): Advanced Features
‚îú‚îÄ Timbre Transfer
‚îú‚îÄ HiFi-GAN Vocoder (optional)
‚îú‚îÄ Analysis Tab
‚îî‚îÄ MIDI 2.0 (optional)
Paso 3: Conversaci√≥n Estructura (C√≥mo Preguntar)
NO hagas esto:
text
"Dame el c√≥digo del Oscillator"
‚Üí Vago, ambiguo, resultado gen√©rico
HAZ esto:
text
"Voy a implementar la Fase 1 (Project Setup).
Necesito:
1. CMakeLists.txt que compile en Mac/Windows/Linux/RPi
2. Directory structure seg√∫n ARCHITECTURE secci√≥n II
3. PluginProcessor.h skeleton (solo interfaces)
4. ParameterDefinitions.h completamente relleno
¬øComienzo?"
Resultado:¬†C√≥digo espec√≠fico, coherente, listo para integrar.

III. CONVERSACIONES TIPO
CONVERSACI√ìN 1: Phase 1 (Project Setup)
text
USER:
"Voy a hacer Phase 1 (Project Setup, Semana 1).
Seg√∫n ARCHITECTURE, necesito:
1. CMakeLists.txt:
   - JUCE 7.0+
   - LibTorch 2.0+
   - Compilar para Mac (Intel + M-series), Windows, Linux, RPi
   - C++17
2. Directory structure (Source/DSP, Source/UI, etc)
3. PluginProcessor.h skeleton:
   - Solo interfaces, sin implementaci√≥n
   - Comentarios de responsabilidad
4. ParameterDefinitions.h completamente relleno
¬øComienzo?"
AI DEVELOPER:
"Perfecto. Voy a crear:
1. CMakeLists.txt profesional
2. Estructura de directorios (ya voy creando)
3. PluginProcessor.h con interfaces claras
4. ParameterDefinitions.h con 50+ par√°metros
¬øAlguna preferencia en LibTorch versi√≥n (2.0 vs 2.1)?"
USER:
"2.1, por favor. CPU-only. ¬øCu√°ndo terminas?"
AI DEVELOPER:
[Entrega archivos]
"Listos los 4 archivos. 
- CMakeLists.txt: Builds en 4 plataformas
- PluginProcessor.h: 150 l√≠neas, todas interfaces
- ParameterDefinitions.h: 50+ par√°metros en namespaces
- Directory structure: 28 directorios creados
¬øCompila en tu m√°quina?"
CONVERSACI√ìN 2: Phase 2a (Oscillator)
text
USER:
"Phase 2, semana 2. Voy a implementar Oscillator.
Requisitos:
- Sine wave output, [-1, 1] range
- Phase en [0, 1) (no radians, para estabilidad num√©rica)
- setFrequency() thread-safe (atomic)
- processSample(phaseModulation) noexcept
- setSampleRate(sr) en prepareToPlay
- Cero allocations post-construcci√≥n
Mira el ejemplo en CODE_STANDARDS > X. CLASE EJEMPLO COMPLETA
Quiero esto ANTES de Envelope, porque Envelope la usar√°."
AI DEVELOPER:
"Entendido. Voy a:
1. Implementar Oscillator.h siguiendo el ejemplo
2. Crear Oscillator.cpp con tests b√°sicos
3. Asegurar zero allocations, noexcept en processSample
4. Usar std::atomic para setFrequency
¬øTest espec√≠ficos?"
USER:
"S√≠:
- Frequency = 440Hz @ 48kHz ‚Üí phase increment = 440/48000 = 0.00917 ‚úì
- processSample() devuelve valores en [-1, 1] ‚úì
- reset() pone phase a 0 ‚úì
- Phase modulation funciona sin aliasing obvio ‚úì"
AI DEVELOPER:
[Entrega Oscillator.h/cpp]
"Listo. 85 l√≠neas Oscillator.h, 40 l√≠neas tests.
- setFrequency() usa atomic<float>
- processSample() marcado noexcept
- Phase modulation integrado
- Todos tus tests pasan ‚úì"
CONVERSACI√ìN 3: Phase 2b (Envelope)
text
USER:
"Phase 2, semana 3. ADSR Envelope.
Requisitos:
- Attack, Decay, Sustain, Release (APVTS par√°metros)
- startNote(), stopNote() para state machine
- processSample() devuelve [0, 1] gain
- Tiempo en ms (APVTS), pero processSample() en samples
- noexcept, zero allocations
Nota: Envelope se usa 4 veces por Voice (amp, filter, pitch, mod).
Por eso DEBE ser ultra-eficiente."
AI DEVELOPER:
"Entendido. Adsr √ó 4 voces √ó 16 voces = 64 envelopes.
Voy a:
1. Enum State { Idle, Attack, Decay, Sustain, Release }
2. Miembro privado sample_rate_ para conversi√≥n ms‚Üísamples
3. Miembro privado counter_ (incrementa en processSample)
4. C√°lculo pendiente = (ms_time / 1000) * sample_rate_
¬øCurve linear o exponencial?"
USER:
"ADSR t√≠pico:
- Attack: linear
- Decay/Release: exponencial (natural para audio)
- Sustain: flat"
AI DEVELOPER:
[Entrega Envelope.h/cpp]
"Listo. 95 l√≠neas Envelope.h.
- State machine con switch/case
- Linear attack, exponential decay/release
- Sustain flat until stopNote
- Tests: verificar timings, shapes"
CONVERSACI√ìN 4: Phase 3 (FeatureExtractor)
text
USER:
"Phase 3, semana 5. FeatureExtractor para red neuronal.
Necesito extraer:
- Pitch (F0) en Hz
- Loudness en dB
- Spectral Centroid (promedio ponderado de frecuencias)
- CQT (Constant-Q Transform, 108 bins, 12 bins/octava)
El modelo neuronal espera este struct:
struct Features {
    float pitch_hz;
    float loudness_db;
    float spectral_centroid;
    std::array<float, 108> cqt;
};
Para CQT:
- Usar Kiss FFT o JUCE FFT
- Configurar para 108 bins (12 bins/octava, ~C1 a C9)
¬øC√≥mo lo ves?"
AI DEVELOPER:
"Perfecto. Voy a:
1. CQTAnalyzer (usando JUCE FFT internally)
2. PitchDetector (autocorrelaci√≥n simple, 50-500Hz range)
3. LoudnessCalculator (RMS + ITU-R weighting)
4. FeatureExtractor que combina todo
¬øBuffer size? (t√≠picamente 2048 samples)"
USER:
"2048 @ 48kHz = 42ms frame. OK.
Pero en RPi, reduce a 512 samples (mejor latencia).
Usa NEXUS_TARGET_RPI compile flag."
AI DEVELOPER:
[Entrega FeatureExtractor.h/cpp, CQTAnalyzer, etc]
"Listo. FeatureExtractor.cpp:
- CQT @ 2048 en PC, 512 en RPi
- Pitch detector (correlation-based)
- Spectral features
- Todos los Features listos para neural net"
CONVERSACI√ìN 5: Phase 6 (Timbre Transfer)
text
USER:
"Phase 6, semana 12. Timbre Transfer (feature: opcional, si CPU permite).
Idea:
- Usuario carga referencia de audio (3-5 segundos)
- Extraer features (CQT, pitch, loudness) de referencia
- Crear 'timbre embedding' en espacio latente
- Red neuronal: input Features + embedding ‚Üí control parameters
Nota: NO hacer inference en tiempo real (caro).
En su lugar: pre-compute embedding, luego interpolar durante s√≠ntesis.
¬øC√≥mo estructurar?"
AI DEVELOPER:
"Entendido. Estructura:
1. TimbreTransferAnalyzer: cargar audio, extraer features, compute embedding
2. TimbreTransferController: interpolar embedding en tiempo real
3. UI: file chooser para referencia, slider para morphing (0-1)
¬øUsar modelo pre-entrenado o modelo custom?"
USER:
"Usar modelo pre-entrenado (ACID/WAV2VEC style).
Si CPU muy restringida (RPi), deshabilitar v√≠a compile flag."
AI DEVELOPER:
[Entrega TimbreTransfer.h/cpp, UI]
"Listo. Timbre transfer integrado:
- An√°lisis offline (no afecta audio)
- Interpolaci√≥n en tiempo real smooth
- Compile flag para RPi"

IV. VALIDACI√ìN EN CADA FASE
Phase 1: Project Setup
text
CHECKLIST:
‚òê CMakeLists.txt compila en todas 4 plataformas (Mac, Win, Linux, RPi)
‚òê Estructura de directorios creada
‚òê PluginProcessor.h skeleton compila sin errores
‚òê ParameterDefinitions.h: 50+ par√°metros definidos
‚òê No hay warnings (compilar con -Wall -Wextra)
‚òê Git repo inicializado con .gitignore apropiado
Phase 2: DSP Core
text
CHECKLIST:
‚òê Oscillator: phase accuracy, frequency sweep, modulation
‚òê Envelope: timing preciso, exponential curves
‚òê ResonatorVoice: note-on/off, all DSP modules connected
‚òê VoiceAllocator: round-robin allocation, note stealing
‚òê CPU: <5% @ 8 voces, 48kHz, 512 buffer (desktop)
‚òê No allocations en processBlock() (verified with ASAN)
Phase 3: Neural Control
text
CHECKLIST:
‚òê FeatureExtractor: CQT, pitch, loudness extraction
‚òê NeuralControlNetwork: model loads, inference <1ms
‚òê Control signals: harmonic amplitudes, noise filter params
‚òê Integration: voice allocation uses neural controls
‚òê LibTorch linked correctly (no runtime errors)
Phase 4: UI
text
CHECKLIST:
‚òê Tabbed interface estructura (5 tabs)
‚òê SynthesizerTab: pitch, harmonic count, noise mix sliders
‚òê APVTS connection: cambiar slider ‚Üí par√°metro cambia
‚òê Responsive scaling: UI legible en 600√ó400 (RPi) y 1920√ó1200
‚òê No crashes on resize, tab switching
‚òê Fonts legibles (@96 DPI RPi, @220 DPI Retina Mac)
Phase 5: MIDI + Polish
text
CHECKLIST:
‚òê MIDI note-on/off routing a voice allocator
‚òê CC mapping (CC 74 cutoff, CC 1 modulation, etc)
‚òê Pitch bend handling
‚òê Sustain pedal (CC 64)
‚òê Preset save/load working
‚òê DAW sync (transport, automation)
‚òê CPU profile: <25% @ 8 voces, full effects (desktop)
‚òê <15% RPi 4 @ 6 voces
Phase 6: Advanced Features
text
CHECKLIST:
‚òê Timbre Transfer loads and morphs
‚òê HiFi-GAN vocoder (if enabled) smooth output
‚òê Analysis tab shows spectrum in real-time
‚òê Waveform oscilloscope smooth
‚òê MIDI 2.0 support (backward compatible)

V. ANTI-PATTERNS: QU√â EVITAR
‚ùå Anti-Pattern 1: Allocations en processBlock()
cpp
// WRONG
void Voice::processBlock(AudioBuffer<float>& buffer) {
    std::vector<float> temp(buffer.getNumSamples());  // ‚ùå Allocation
    for (int i = 0; i < buffer.getNumSamples(); ++i) {
        temp[i] = process_sample();
    }
}
// CORRECT
void Voice::processBlock(AudioBuffer<float>& buffer) {
    float* out = buffer.getWritePointer(0);
    for (int i = 0; i < buffer.getNumSamples(); ++i) {
        out[i] = process_sample();
    }
}
‚ùå Anti-Pattern 2: Locks en Audio Thread
cpp
// WRONG
void Voice::processBlock(AudioBuffer<float>& buffer) {
    std::lock_guard<std::mutex> lock(param_mutex);  // ‚ùå Lock
    float cutoff = param_cutoff;
}
// CORRECT
void Voice::processBlock(AudioBuffer<float>& buffer) {
    float cutoff = param_cutoff.load(std::memory_order_acquire);  // ‚úì Atomic
}
‚ùå Anti-Pattern 3: Variables Sueltas (no APVTS)
cpp
// WRONG
class Voice {
    float pitch_coarse = 0.0f;
    float pitch_fine = 0.0f;
    // Manual sync con DAW = desastador
};
// CORRECT
class Voice {
    // Lee directo de APVTS en processBlock()
    float pitch_coarse = *apvts.getRawParameterValue("pitchCoarse");
    // DAW sync autom√°tico
}
‚ùå Anti-Pattern 4: Magic Numbers
cpp
// WRONG
for (int i = 0; i < 64; ++i) {  // ¬øPor qu√© 64?
    oscillators[i].process();
}
// CORRECT
static constexpr int HARMONIC_COUNT = 64;
for (int i = 0; i < HARMONIC_COUNT; ++i) {
    oscillators[i].process();
}
‚ùå Anti-Pattern 5: Raw Pointers
cpp
// WRONG
Voice* voice = new Voice();
// ¬øQui√©n lo deleta? ¬øCu√°ndo? ¬øSi hay excepci√≥n?
// CORRECT
auto voice = std::make_unique<Voice>();
// Destruido autom√°ticamente
‚ùå Anti-Pattern 6: Logging en Audio Thread
cpp
// WRONG
void Voice::processBlock(...) {
    DBG("Processing voice");  // ‚ùå Thread violation
}
// CORRECT
void Voice::processBlock(...) {
    if (should_log_) {
        log_queue.push("Processing voice");  // ‚úì Lock-free
    }
}
void TimerCallback() {
    std::string msg;
    while (log_queue.pop(msg)) DBG(msg);  // UI thread
}

VI. TIMELINE REALISTA
Week
Phase
Tasks
Deliverable
1
Phase 1
Project setup, CMakeLists, ParameterDefinitions
Compiling skeleton
2-3
Phase 2a
Oscillator, Envelope, basic Voice
8 voices polyphony
4
Phase 2b
VoiceAllocator, MIDI routing
Note-on/off working
5-6
Phase 3
FeatureExtractor, Neural inference
Neural controls active
7-8
Phase 4
Tabbed UI, APVTS connection
All 5 tabs functional
9
Phase 5a
Preset save/load, DAW sync
Presets working
10
Phase 5b
CPU optimization, profiling
<25% CPU (desktop)
11+
Phase 6
Timbre transfer, vocoder, MIDI 2.0 (opt)
Advanced features
Total: 16 semanas (4 meses) desde cero a production-ready.

VII. C√ìMO HACER PREGUNTAS EFECTIVAS
‚ùå Vago
text
"Necesito un sintetizador"
"C√≥mo hago MIDI"
"Optimiza el c√≥digo"
‚Üí Resultado: Gen√©rico, sin contexto, in√∫til.
‚úÖ Espec√≠fico
text
"Phase 2, semana 2.
Voy a implementar Oscillator.h seg√∫n ARCHITECTURE secci√≥n V.1 + CODE_STANDARDS ejemplo.
Necesito:
- Sine wave, phase [0,1)
- setFrequency() atomic para thread-safety
- processSample(phaseModulation) noexcept
- Zero allocations post-construcci√≥n
Quiero esto COMPLETADO (header + implementation + tests) antes de pasar a Envelope.
¬øAlg√∫n issue t√©cnico que vea?"
‚Üí Resultado: C√≥digo espec√≠fico, coherente, integrable.

VIII. RED FLAGS: Signos de Problema
üö© Red Flag 1: "Voy a simplificar la arquitectura"
text
AI DEV: "La separaci√≥n SoC es overkill. Voy a meter todo en 
         PluginProcessor para reducir complejidad."
RESPONSE: ‚ùå RECHAZAR
Raz√≥n: Violates ARCHITECTURE secci√≥n III.A. SoC es requisito, 
       no opci√≥n. Eso fue determinado deliberadamente.
üö© Red Flag 2: "No necesitamos thread-safety en audio"
text
AI DEV: "El compilador maneja eso autom√°ticamente"
RESPONSE: ‚ùå RECHAZAR
Raz√≥n: Audio thread safety es manual. Necesita:
       - std::atomic para par√°metros
       - Zero allocations en processBlock()
       - No locks
Esto est√° en ARCHITECTURE secci√≥n III.C.
üö© Red Flag 3: "Phase Adelante, UI despu√©s"
text
AI DEV: "Voy a saltar Phase 4 (UI) porque es tedioso. 
         Primero todo el DSP, UI al final."
RESPONSE: ‚ö†Ô∏è RECONSIDERAR
Mejor: Phase 4 temprano permite testing interactivo.
       Integraci√≥n APVTS desde inicio = menos refactoring.
üö© Red Flag 4: "Usamos STL containers en processBlock()"
text
AI DEV: "Para eficiencia, voy a usar std::vector en lugar de std::array"
RESPONSE: ‚ùå RECHAZAR
Raz√≥n: std::vector puede allocate/reallocate. Prohibido en audio thread.
       Usa std::array (fixed-size, stack allocation).

IX. HERRAMIENTAS RECOMENDADAS
Build & Compilation
CMake 3.16+: Configuraci√≥n multiplataforma
Ninja: Backend r√°pido
ccache: Compilaci√≥n incremental
Profiling
perf¬†(Linux/RPi): CPU profiling
Instruments¬†(Mac): Thread profiling, memory
Visual Studio Profiler¬†(Windows)
ASAN¬†(AddressSanitizer): Memory leaks en development
Code Quality
clang-format: Code formatting (use¬†.clang-format¬†en repo)
clang-tidy: Static analysis (catch errors early)
valgrind¬†(Linux): Memory profiling
MIDI Testing
LoopMIDI¬†(Windows): Virtual MIDI ports
IAC Driver¬†(Mac): Inter-App Audio MIDI
a2jmidid¬†(Linux): ALSA ‚Üí JACK bridge

X. FAQ
P: ¬øCu√°nto tiempo en Phase 1?
R: 4-8 horas (CMakeLists debugging puede ser tedioso).
P: ¬øNecesito TODAS las features de Phase 6?
R: No. Timbre Transfer y HiFi-GAN son opcional. MIDI 2.0 es backward-compatible.
P: ¬øQu√© si encuentro un bug en especificaci√≥n?
R: Se√±√°lalo. Si es error real, ajusta y documenta. Especificaci√≥n es livingdoc.
P: ¬øPuedo cambiar librer√≠a X por Y?
R: Si es equivalente en API y no viola requisitos (thread-safety, portability, CPU), probablemente s√≠. Consulta primero.
P: ¬øQu√© pasa si RPi no compila?
R: RPi compilation es Phase 5. Prioridad: Desktop first, RPi optimization despu√©s.
P: ¬øCu√°ndo empiezo con tests?
R: Phase 1. Unit tests en cada componente DSP. Esto no es opcional.
P: ¬øC√≥mo manejo backwards compatibility?
R: Presets guardados deben seguir siendo v√°lidos. APVTS maneja esto autom√°ticamente si a√±ades par√°metros (nuevos par√°metros = default value).
P: ¬øY si memoria no es suficiente?
R: En RPi, reduce HARMONIC_COUNT a 32, FFT_SIZE a 512, VOICE_COUNT a 6. Estos flags existen en ARCHITECTURE.

XI. ENTREGABLES ESPERADOS POR PHASE
Phase 1 Deliverables
text
nexus/
‚îú‚îÄ‚îÄ CMakeLists.txt ‚úì
‚îú‚îÄ‚îÄ Source/
‚îÇ   ‚îú‚îÄ‚îÄ Main/PluginProcessor.h (skeleton) ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ State/ParameterDefinitions.h (completo) ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ DSP/ (directory structure)
‚îÇ   ‚îú‚îÄ‚îÄ UI/ (directory structure)
‚îÇ   ‚îú‚îÄ‚îÄ MIDI/ (directory structure)
‚îÇ   ‚îî‚îÄ‚îÄ ... (otros directorios)
‚îú‚îÄ‚îÄ Models/ (directory)
‚îú‚îÄ‚îÄ Presets/ (directory)
‚îú‚îÄ‚îÄ Tests/ (directory)
‚îî‚îÄ‚îÄ README.md
Phase 2 Deliverables
text
Source/DSP/
‚îú‚îÄ‚îÄ CoreModules/
‚îÇ   ‚îú‚îÄ‚îÄ Oscillator.h/cpp ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ Envelope.h/cpp ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ NoiseGenerator.h/cpp ‚úì
‚îÇ   ‚îî‚îÄ‚îÄ FilterBank.h/cpp ‚úì
‚îú‚îÄ‚îÄ Synthesis/
‚îÇ   ‚îú‚îÄ‚îÄ ResonatorVoice.h/cpp ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ VoiceAllocator.h/cpp ‚úì
‚îî‚îÄ‚îÄ Utils/
    ‚îú‚îÄ‚îÄ DSPMath.h/cpp
    ‚îî‚îÄ‚îÄ LookupTables.h/cpp
Tests/
‚îú‚îÄ‚îÄ OscillatorTests.cpp ‚úì
‚îú‚îÄ‚îÄ EnvelopeTests.cpp ‚úì
‚îî‚îÄ‚îÄ DSPPerformanceTests.cpp ‚úì
Phase 3 Deliverables
text
Source/DSP/
‚îú‚îÄ‚îÄ Analysis/
‚îÇ   ‚îú‚îÄ‚îÄ FeatureExtractor.h/cpp ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ CQTAnalyzer.h/cpp ‚úì
‚îÇ   ‚îî‚îÄ‚îÄ AudioMetrics.h/cpp ‚úì
‚îú‚îÄ‚îÄ Neural/
‚îÇ   ‚îú‚îÄ‚îÄ NeuralControlNetwork.h/cpp ‚úì
‚îÇ   ‚îî‚îÄ‚îÄ ModelLoader.h/cpp ‚úì
‚îî‚îÄ‚îÄ Synthesis/
    ‚îî‚îÄ‚îÄ DDSPSynthesizer.h/cpp ‚úì
Phase 4 Deliverables
text
Source/UI/
‚îú‚îÄ‚îÄ Tabs/
‚îÇ   ‚îú‚îÄ‚îÄ SynthesizerTab.h/cpp ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ ModulationTab.h/cpp ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ TimbreTab.h/cpp ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ EffectsTab.h/cpp ‚úì
‚îÇ   ‚îî‚îÄ‚îÄ AnalysisTab.h/cpp ‚úì
‚îú‚îÄ‚îÄ Components/
‚îÇ   ‚îú‚îÄ‚îÄ XYPad.h/cpp ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ VerticalSlider.h/cpp ‚úì
‚îÇ   ‚îî‚îÄ‚îÄ ... (otros componentes)
‚îî‚îÄ‚îÄ Styling/
    ‚îú‚îÄ‚îÄ Colors.h ‚úì
    ‚îú‚îÄ‚îÄ Theme.h ‚úì
    ‚îî‚îÄ‚îÄ UIScaling.h/cpp ‚úì

CONCLUSI√ìN
Esta briefing es tu gu√≠a. √ösala para:
‚úÖ Entender qu√© hacer en cada phase
‚úÖ Comunicar claramente con AI developer
‚úÖ Validar entregables
‚úÖ Identificar problemas temprano
Si sigues este flujo, en 16 semanas tendr√°s un sintetizador neural profesional.
¬°√âxito!¬†üöÄ

FIN DEL ARCHIVO 4 (AI_DEVELOPER_BRIEFING.md)

